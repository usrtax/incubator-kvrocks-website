"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[128],{3905:function(e,t,o){o.d(t,{Zo:function(){return d},kt:function(){return m}});var n=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var o=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(o),m=a,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||r;return o?n.createElement(h,i(i({ref:t},d),{},{components:o})):n.createElement(h,i({ref:t},d))}));function m(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=o.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<r;c++)i[c]=o[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}p.displayName="MDXCreateElement"},2016:function(e,t,o){o.r(t),o.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var n=o(7462),a=o(3366),r=(o(7294),o(3905)),i=["components"],l={},s="Kvrocks Cluster Introduction",c={unversionedId:"Cluster/kvrocks-cluster-introduction",id:"Cluster/kvrocks-cluster-introduction",title:"Kvrocks Cluster Introduction",description:"Before releasing the cluster mode of Kvrocks, we usually used the pre-sharding way to scale out the capacity like sharding with Twemproxy, and used Redis Sentinel to guarantee the availability. Although it works well in most scenes since the capacity of Kvrocks was far larger than Redis, it\u2019s still trivial to scale-out in-flight, so we decided to implement the cluster mode to make it easier.",source:"@site/docs/07-Cluster/00-kvrocks-cluster-introduction.md",sourceDirName:"07-Cluster",slug:"/Cluster/kvrocks-cluster-introduction",permalink:"/docs/Cluster/kvrocks-cluster-introduction",draft:!1,editUrl:"https://github.com/apache/incubator-kvrocks-website/tree/main/docs/07-Cluster/00-kvrocks-cluster-introduction.md",tags:[],version:"current",lastUpdatedBy:"Ruixiang Tan",lastUpdatedAt:1662905954,formattedLastUpdatedAt:"9/11/2022",sidebarPosition:0,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"How to backup",permalink:"/docs/Operations/how-to-backup"},next:{title:"How we use RocksDB in Kvrocks",permalink:"/docs/Performance/how-we-use-rocksdb"}},d={},u=[{value:"Internal Design",id:"internal-design",level:2},{value:"Topology Management",id:"topology-management",level:3},{value:"Node Management",id:"node-management",level:3},{value:"Client Access",id:"client-access",level:3},{value:"Deploy And Operate",id:"deploy-and-operate",level:3},{value:"Cluster Scaling",id:"cluster-scaling",level:3},{value:"Summary",id:"summary",level:2}],p={toc:u};function m(e){var t=e.components,o=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"kvrocks-cluster-introduction"},"Kvrocks Cluster Introduction"),(0,r.kt)("p",null,"Before releasing the cluster mode of Kvrocks, we usually used the pre-sharding way to scale out the capacity like sharding with Twemproxy, and used Redis Sentinel to guarantee the availability. Although it works well in most scenes since the capacity of Kvrocks was far larger than Redis, it\u2019s still trivial to scale-out in-flight, so we decided to implement the cluster mode to make it easier."),(0,r.kt)("p",null,"There\u2019re two main types of Redis cluster solutions in the industry:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Redis cluster decentralized solution"),(0,r.kt)("li",{parentName:"ul"},"Codis centralized solution")),(0,r.kt)("p",null,"For Redis cluster, the biggest advantage was NOT needing to depend on other components, but the shortcoming was also obvious that it\u2019s hard to write the right implementation and not easy to maintain the cluster topology. Another big issue was Gossip protocol would limit the cluster size. For Codis solution, we need to import the proxy and centralized storage to keep the metadata, the proxy also added extra network communication cost and delay."),(0,r.kt)("p",null,"In Kvrocks cluster design, we want to integrate advantages between those solutions, can access Kvrocks without the proxy, and scale-out easily."),(0,r.kt)("h2",{id:"internal-design"},"Internal Design"),(0,r.kt)("p",null,"Each Kvrocks node can act as Redis node which can offer the cluster topology directly, and the Redis cluster client can also work on the Kvrocks cluster without any modifications. The topology was managed by the other control panel component which can avoid the complexity of the Gossip protocol(Redis community takes many years to complete the Gossip on cluster solution)."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/18362176/153791709-3a50210e-40b5-4604-ade4-29a8de0559c6.png",alt:"cluster"})),(0,r.kt)("h3",{id:"topology-management"},"Topology Management"),(0,r.kt)("p",null,"Kvrocks uses the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/KvrocksLabs/kvrocks/pull/302"},"Clusterx SetNodes")," command to set up the cluster topology, be careful that we should apply the entire topology information to all nodes since nodes didn't communicate with each other. The command is like below:"),(0,r.kt)("p",null,"CLUSTERX SETNODES ",(0,r.kt)("inlineCode",{parentName:"p"},"$ALL_NODES_INFO")," ",(0,r.kt)("inlineCode",{parentName:"p"},"$VERSION")," ",(0,r.kt)("inlineCode",{parentName:"p"},"FORCE")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$ALL_NODES_INFO"),": was the cluster topology information, format: : ",(0,r.kt)("inlineCode",{parentName:"li"},"$node_id")," ",(0,r.kt)("inlineCode",{parentName:"li"},"$ip")," ",(0,r.kt)("inlineCode",{parentName:"li"},"$port")," ",(0,r.kt)("inlineCode",{parentName:"li"},"$role")," ",(0,r.kt)("inlineCode",{parentName:"li"},"$master_node_id")," ",(0,r.kt)("inlineCode",{parentName:"li"},"$slot_range"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$node_id"),": 40 chars string, it represents as the unique id in the cluster"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$ip")," and  ",(0,r.kt)("inlineCode",{parentName:"li"},"$port"),": the node IP address and the listening port"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$role"),": node's role, should be one of master or slave"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$master_node_id"),":  set it to the master node id when the current node's role was a slave and set ",(0,r.kt)("inlineCode",{parentName:"li"},"-")," if it's master"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"slot_range"),": slots were served by current node, the format can be the range or single value, like 0-100 200 205 which means slots 0 to 100, 200 and 205 were served by this node"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$VERSION"),": the topology information version is used to control update the order, the topology information can be updated iff the version is newer than the current version"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FORCE"),": force update the topology information without verifying the version, we can use this flag when the topology information was totally broken")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'CLUSTERX SETNODES\n  "67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 127.0.0.1 30002 master - 5461-10922 16380 16383\n    07c37dfeb235213a872192d90877d0cd55635b91 127.0.0.1 30004 slave 67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1"\n  1\n')),(0,r.kt)("p",null,"Although Kvrocks can recognize the node id by comparing the ",(0,r.kt)("inlineCode",{parentName:"p"},"ip"),":",(0,r.kt)("inlineCode",{parentName:"p"},"port")," pair then finding out the serving slots, but users may set the IP address to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.0.0.0")," so that we can't match the right topology information. So Kvrocks gives the extra command ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/KvrocksLabs/kvrocks/pull/302",title:"CLUSTERX SETNODEID command"},"CLUSTERX SETNODEID")," to set the id. The format is like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"CLUSTERX SETNODEID $NODE_ID\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"$NODE_ID"),": should be 40 chars unique id in cluster"),(0,r.kt)("h3",{id:"node-management"},"Node Management"),(0,r.kt)("p",null,"Kvrocks cluster can be set up as simple as using those cluster commands, we even can write a script to watch and apply cluster changes. Those commands can be integrated into those companies which have their own cluster solution. Kvrocks also offers the ",(0,r.kt)("inlineCode",{parentName:"p"},"CLUSTERX\xa0VERSION")," command to inspect current cluster topology information, the controller can force to update topology information when the version was out of date or wrong."),(0,r.kt)("p",null,"For a complete cluster solution, we need to depend on another controller to manage the topology information, failure detection, and failover. Kvrocks team was also developing the official controller to make the cluster manage and operate easier. But the manual resource was the bottleneck, welcome anyone who was interested in this project to build together."),(0,r.kt)("h3",{id:"client-access"},"Client Access"),(0,r.kt)("p",null,"Users can use Redis Cluster SDK to access the Kvrocks cluster since it's compatible with the Redis cluster solution(Kvrocks supported ",(0,r.kt)("inlineCode",{parentName:"p"},"CLUSTER\xa0NODES")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CLUSTER\xa0SLOTS"),"  command to respond to the cluster topology).  Kvrocks also responds to the ",(0,r.kt)("inlineCode",{parentName:"p"},"MOVED $slot_id\xa0$ip:$port")," to redirect the target node when the slot was NOT served by the current node. You can also use the Redis Cluster Proxy like ",(0,r.kt)("inlineCode",{parentName:"p"},"redis-cluster-proxy")," to hide the cluster topology."),(0,r.kt)("h3",{id:"deploy-and-operate"},"Deploy And Operate"),(0,r.kt)("p",null,"Users need to self-manage the cluster topology information since the Kvrocks controller was still under development. The deployment steps were below:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Deploy Kvrocks nodes"),(0,r.kt)("li",{parentName:"ol"},"Design the kvrocks topology which was mentioned at #Topology Management"),(0,r.kt)("li",{parentName:"ol"},"Set node unique id for each node by using ",(0,r.kt)("inlineCode",{parentName:"li"},"CLUSTER\xa0SETNODEID")," command"),(0,r.kt)("li",{parentName:"ol"},"Apply the topology information to all nodes by using ",(0,r.kt)("inlineCode",{parentName:"li"},"CLUSTER\xa0NODES")," command")),(0,r.kt)("p",null,"Kvrocks would auto-setup the master-slave replication after receiving the setup topology command, and repeats steps 2-4 when we want to switch the node role or number."),(0,r.kt)("p",null," Currently, Kvrocks topology modification was based on full state, that's we need to sync the full topology information to each node, which may cause high network and cpu cost but it can guarantee the correctness of the cluster. Also, the version-based modification can help us to achieve the increment modification if we want to do that, we would offer a way to add, update and delete nodes to make operation easier."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cluster Command And Safty")),(0,r.kt)("p",null,"To guarantee the correctness of client SDK, we rename the CLUSTER command to CLUSTERX to prevent the topology can being modified casually, but we can still use the CLUSTER command to fetch the cluster topology information."),(0,r.kt)("h3",{id:"cluster-scaling"},"Cluster Scaling"),(0,r.kt)("p",null,"Kvrocks data migration was based on the slot instead of the key-based like Reids,  we can migrate one slot to another node at once. Kvrocks storage was based on disk instead of memory, so the key migration may be time cost. Now, the controller o DBA can use the CLUSTER MIGRATE command to migrate the slot. For more information can see the PR ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/KvrocksLabs/kvrocks/pull/430"},"#430"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Migrate Command")),(0,r.kt)("p",null,"CLUSTERX SETSLOT ",(0,r.kt)("inlineCode",{parentName:"p"},"$slot")," NODE ",(0,r.kt)("inlineCode",{parentName:"p"},"$node_id")," ",(0,r.kt)("inlineCode",{parentName:"p"},"$new_version")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$slot"),": assign which slot to be migrated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NODE"),":same as the Redis cluster setslot"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$dest_nodeid"),": which node of the slot is to be migrated"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$new_version"),": the version of the topology information, noted that the version MUST be newer than the old version, or the node would refuse to apply the modification.")),(0,r.kt)("p",null,"We need to use the CLUSTERX MIGRATE command to migrate the slot then use CLUSTER SETSLOT to modify the topology information."),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"Kvrocks cluster implementation was compatible with the Redis cluster, in which users can use the Redis cluster client to access the Kvrocks cluster, also didn't have the extra proxy latency like the Codis solution. By the way, Kvrocks cluster topology management and scaling have already finished from the latest version 2.0.6. We will continue improving the visibility, operation, and cluster management, to make the cluster better and easier."),(0,r.kt)("p",null,"For the Kvrocks controller, the community was building the official ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/KvrocksLabs/kvrocks_controller/tree/develop"},"controller")," to make the cluster management easier. Welcome anyone who was interested."))}m.isMDXComponent=!0}}]);